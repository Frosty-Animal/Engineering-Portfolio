<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CompArc</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="icon" type="image/png" href="WebsiteTitlePicture.png">
  <!-- FontAwesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
  <style>
    /* Remove sidebar styles and add new collapsible section styles */
    .content-wrapper {
      margin-left: 0; /* Remove sidebar margin */
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }

    /* Summary section styling */
    .project-summary {
      background: linear-gradient(135deg, #ec7a1c, #bc6116);
      color: white;
      padding: 30px;
      border-radius: 15px;
      margin: 30px 0;
      box-shadow: 0 10px 30px rgba(236, 122, 28, 0.3);
    }

    .project-summary h2 {
      margin: 0 0 15px 0;
      font-size: 1.8rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .project-summary .summary-content {
      font-size: 1.1rem;
      line-height: 1.6;
      margin-bottom: 20px;
    }

    .project-highlights {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }

    .highlight-item {
      background: rgba(255, 255, 255, 0.1);
      padding: 15px;
      border-radius: 8px;
      text-align: center;
      backdrop-filter: blur(5px);
    }

    .highlight-value {
      font-size: 1.5rem;
      font-weight: bold;
      display: block;
    }

    .highlight-label {
      font-size: 0.9rem;
      opacity: 0.9;
    }

    /* Collapsible section styles */
    .collapsible-section {
      background: white;
      border-radius: 10px;
      margin: 20px 0;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      overflow: hidden;
      transition: all 0.3s ease;
    }

    .section-header {
      background: #f8f6f3;
      padding: 20px 25px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.3s ease;
      border-left: 4px solid #ec7a1c;
    }

    .section-header:hover {
      background: #f0ede8;
    }

    .section-header.active {
      background: #ec7a1c;
      color: white;
    }

    .section-title {
      font-size: 1.3rem;
      font-weight: 600;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .section-icon {
      font-size: 1.1rem;
    }

    .toggle-icon {
      font-size: 1.2rem;
      transition: transform 0.3s ease;
    }

    .section-header.active .toggle-icon {
      transform: rotate(180deg);
    }

    .section-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease, padding 0.3s ease;
      background: white;
    }

    .section-content.active {
      max-height: 1000px; /* Adjust based on your content */
      padding: 25px;
    }

    .section-content p,
    .section-content ul,
    .section-content ol {
      margin-bottom: 15px;
      line-height: 1.6;
      color: #444;
    }

    .section-content h3 {
      color: #ec7a1c;
      margin-top: 20px;
      margin-bottom: 10px;
    }

    .section-content ul {
      padding-left: 20px;
    }

    .section-content li {
      margin-bottom: 8px;
    }

    /* Tech stack styling */
    .tech-stack {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 15px 0;
    }

    .tech-item {
      background: #ec7a1c;
      color: white;
      padding: 6px 12px;
      border-radius: 15px;
      font-size: 0.85rem;
      font-weight: 500;
    }

    /* Results section special styling */
    .results-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }

    .result-card {
      background: #f8f6f3;
      padding: 20px;
      border-radius: 10px;
      border-left: 4px solid #ec7a1c;
    }

    .result-card h4 {
      color: #ec7a1c;
      margin: 0 0 10px 0;
    }

    /* Slideshow adjustments for new layout */
    .slideshow-container {
      max-width: 100%;
      margin: 30px 0;
    }

    /* Back button styling */
    .back-button {
      position: sticky;
      top: 20px;
      z-index: 100;
      margin-bottom: 20px;
    }

    .back-button a {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 12px 20px;
      background: #44443b;
      color: white;
      text-decoration: none;
      border-radius: 25px;
      font-weight: 500;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .back-button a:hover {
      background: #ec7a1c;
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(236, 122, 28, 0.3);
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .content-wrapper {
        padding: 15px;
      }

      .project-summary {
        padding: 20px;
      }

      .project-highlights {
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }

      .section-header {
        padding: 15px 20px;
      }

      .section-content.active {
        padding: 20px;
      }

      .results-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>

<div class="topnav">
  <a href="./index.html">Home</a>
  <a class="active" href="./projects.html">Projects</a>
  <a href="./resume.html">Resume</a>
  <a href="./about.html">About</a>
</div>

<div class="content-wrapper">
  <div class="back-button">
    <a href="./projects.html">
      <i class="fas fa-arrow-left"></i>
      Back to Projects
    </a>
  </div>

  <div class="content">
    <h1>Project: Racing Drones for Competition</h1>
  </div>

  <!-- PROJECT SUMMARY SECTION -->
  <div class="project-summary">
    <h2>
      <i class="fas fa-clipboard-list"></i>
      Executive Summary
    </h2>
    <div class="summary-content">
      Built high-performance racing drones from scratch for competitive flying and learning. This project involved
      designing, assembling, and programming custom FPV racing drones capable of reaching speeds over 100 MPH.
      Developed through hands-on experience with electronics, soldering, and flight control systems.
    </div>

    <div class="project-highlights">
      <div class="highlight-item">
        <span class="highlight-value">100+</span>
        <span class="highlight-label">MPH Top Speed</span>
      </div>
      <div class="highlight-item">
        <span class="highlight-value">6 min</span>
        <span class="highlight-label">Flight Time</span>
      </div>
      <div class="highlight-item">
        <span class="highlight-value">10 hrs</span>
        <span class="highlight-label">Build Time</span>
      </div>
      <div class="highlight-item">
        <span class="highlight-value">Summer 2023</span>
        <span class="highlight-label">Completed</span>
      </div>
    </div>
  </div>

  <!-- SLIDESHOW -->
  <div class="slideshow-container">
    <div class="slide active">
      <img src="https://raw.githubusercontent.com/Frosty-Animal/Engineering-Portfolio/main/IMG_4080.jpg" alt="Drone Build Process" style="width:100%">
    </div>
    <div class="slide">
      <img src="https://raw.githubusercontent.com/Frosty-Animal/Engineering-Portfolio/main/IMG_4091.jpg" alt="Completed Drone" style="width:100%">
    </div>
    <div class="slide">
      <img src="https://raw.githubusercontent.com/Frosty-Animal/Engineering-Portfolio/main/IMG_5229.jpg" alt="Electronics Assembly" style="width:100%">
    </div>
    <div class="slide">
      <img src="https://raw.githubusercontent.com/Frosty-Animal/Engineering-Portfolio/main/IMG_5231.jpg" alt="Flight Testing" style="width:100%">
    </div>
    <div class="slide">
      <img src="https://raw.githubusercontent.com/Frosty-Animal/Engineering-Portfolio/main/IMG_5232.jpg" alt="Racing Setup" style="width:100%">
    </div>

    <button class="prev" onclick="plusSlides(-1)">&#10094;</button>
    <button class="next" onclick="plusSlides(1)">&#10095;</button>
  </div>

  <div class="dots">
    <span class="dot" onclick="currentSlide(1)"></span>
    <span class="dot" onclick="currentSlide(2)"></span>
    <span class="dot" onclick="currentSlide(3)"></span>
    <span class="dot" onclick="currentSlide(4)"></span>
    <span class="dot" onclick="currentSlide(5)"></span>
  </div>

  <!-- COLLAPSIBLE SECTIONS -->
  <div class="collapsible-section">
    <div class="section-header" onclick="toggleSection('overview')">
      <div class="section-title">
        <i class="fas fa-eye section-icon"></i>
        Project Overview
      </div>
      <i class="fas fa-chevron-down toggle-icon"></i>
    </div>
    <div class="section-content" id="overview">
      <p>
        This for-fun project was started by me and a couple of friends who were bored at work one day and wanted something
        new to break the monotony of work and school. We ended up fixating on racing drones after recently watching
        several drone racing tournaments and wanted to test our own skills.
      </p>
      <p>
        We ended up even making a club out of it for a while during my sophomore year of college. Each drone took about
        10 hours to build and program as well as being a good starting experience on getting proficient at soldering,
        as there were a lot of parts that needed to be hand soldered... and learning how to deal with burns as there
        were a lot of those as well.
      </p>
      <p>
        At top speeds the drones could get over 100 MPH and had a battery life of roughly 6 minutes (dependent on how
        long your drone would be flying at max speeds).
      </p>
    </div>
  </div>

  <div class="collapsible-section">
    <div class="section-header" onclick="toggleSection('materials')">
      <div class="section-title">
        <i class="fas fa-cogs section-icon"></i>
        Components & Materials
      </div>
      <i class="fas fa-chevron-down toggle-icon"></i>
    </div>
    <div class="section-content" id="materials">
      <h3>Frame & Structure</h3>
      <ul>
        <li>Carbon fiber racing frame (5-inch class)</li>
        <li>Lightweight aluminum standoffs</li>
        <li>3D printed camera mounts and accessories</li>
      </ul>

      <h3>Electronics</h3>
      <ul>
        <li>Flight controller (F4/F7 processor)</li>
        <li>Electronic Speed Controllers (ESCs) - 4x 30A</li>
        <li>Brushless motors - 4x 2300KV</li>
        <li>5.8GHz video transmitter</li>
        <li>FPV camera with wide-angle lens</li>
        <li>2.4GHz radio receiver</li>
      </ul>

      <h3>Power System</h3>
      <ul>
        <li>4S LiPo batteries (1500mAh)</li>
        <li>Power distribution board</li>
        <li>Voltage regulators for different components</li>
      </ul>

      <div class="tech-stack">
        <span class="tech-item">Betaflight</span>
        <span class="tech-item">Soldering</span>
        <span class="tech-item">FPV Systems</span>
        <span class="tech-item">LiPo Management</span>
        <span class="tech-item">RF Systems</span>
      </div>
    </div>
  </div>

  <div class="collapsible-section">
    <div class="section-header" onclick="toggleSection('assembly')">
      <div class="section-title">
        <i class="fas fa-wrench section-icon"></i>
        Assembly & Programming
      </div>
      <i class="fas fa-chevron-down toggle-icon"></i>
    </div>
    <div class="section-content" id="assembly">
      <h3>Build Process</h3>
      <ol>
        <li><strong>Frame Assembly:</strong> Mounted motors to carbon fiber arms and assembled the main frame structure</li>
        <li><strong>Electronics Integration:</strong> Installed flight controller, ESCs, and power distribution systems</li>
        <li><strong>Soldering:</strong> Hand-soldered all connections between motors, ESCs, and flight controller</li>
        <li><strong>FPV Setup:</strong> Mounted and configured camera and video transmission system</li>
        <li><strong>Receiver Installation:</strong> Integrated radio receiver for remote control</li>
      </ol>

      <h3>Software Configuration</h3>
      <p>
        Used Betaflight configurator to program the flight controller, including:
      </p>
      <ul>
        <li>Motor mapping and direction configuration</li>
        <li>PID tuning for stable flight characteristics</li>
        <li>Radio channel mapping and failsafe settings</li>
        <li>Flight modes and switch assignments</li>
        <li>OSD (On-Screen Display) configuration for telemetry</li>
      </ul>

      <h3>Challenges Overcome</h3>
      <ul>
        <li>Learning precision soldering techniques for small components</li>
        <li>Managing heat dissipation in compact electronics layout</li>
        <li>Tuning flight characteristics for different flying styles</li>
        <li>Dealing with vibration isolation for camera stability</li>
      </ul>
    </div>
  </div>

  <div class="collapsible-section">
    <div class="section-header" onclick="toggleSection('testing')">
      <div class="section-title">
        <i class="fas fa-plane section-icon"></i>
        Testing & Optimization
      </div>
      <i class="fas fa-chevron-down toggle-icon"></i>
    </div>
    <div class="section-content" id="testing">
      <h3>Flight Testing Process</h3>
      <p>
        Conducted extensive flight testing in controlled environments to validate performance and safety:
      </p>
      <ul>
        <li>Initial hover tests to verify motor function and flight controller response</li>
        <li>Progressive speed testing to determine maximum safe velocities</li>
        <li>Maneuverability testing through obstacle courses</li>
        <li>Battery life optimization under different flight profiles</li>
        <li>Video transmission range and quality testing</li>
      </ul>

      <h3>Performance Optimization</h3>
      <ul>
        <li>Fine-tuned PID controllers for responsive but stable flight</li>
        <li>Optimized propeller selection for speed vs. efficiency trade-offs</li>
        <li>Adjusted camera angles for optimal FPV racing experience</li>
        <li>Weight distribution optimization for balanced flight characteristics</li>
      </ul>

      <h3>Safety Protocols</h3>
      <ul>
        <li>Established safe flying zones away from people and property</li>
        <li>Implemented multiple failsafe mechanisms</li>
        <li>Regular pre-flight inspections and maintenance schedules</li>
        <li>Emergency landing procedures and battery monitoring</li>
      </ul>
    </div>
  </div>

  <div class="collapsible-section">
    <div class="section-header" onclick="toggleSection('results')">
      <div class="section-title">
        <i class="fas fa-trophy section-icon"></i>
        Results & Outcomes
      </div>
      <i class="fas fa-chevron-down toggle-icon"></i>
    </div>
    <div class="section-content" id="results">
      <div class="results-grid">
        <div class="result-card">
          <h4>Performance Achieved</h4>
          <ul>
            <li>Top speed: 100+ MPH</li>
            <li>Flight time: 6 minutes at racing speeds</li>
            <li>Video range: 1+ mile with clear signal</li>
            <li>Response time: <20ms control latency</li>
          </ul>
        </div>

        <div class="result-card">
          <h4>Skills Developed</h4>
          <ul>
            <li>Advanced soldering and electronics assembly</li>
            <li>PID control system tuning</li>
            <li>RF system design and troubleshooting</li>
            <li>Mechanical design and weight optimization</li>
          </ul>
        </div>

        <div class="result-card">
          <h4>Project Impact</h4>
          <ul>
            <li>Founded temporary drone racing club</li>
            <li>Mentored other students in drone building</li>
            <li>Applied skills to later engineering projects</li>
            <li>Developed appreciation for systems integration</li>
          </ul>
        </div>
      </div>

      <h3>Video Demonstration</h3>
      <div class="code-section">
        <div class="code-with-lines">
          <div class="code-header">
            <span class="code-filename">📄 riscvpipelined.sv</span>
            <span class="code-language">System Verilog</span>
          </div>
          <pre><code><span class="line">// 5-Stage RISC-V Pipeline Processor</span>

<span class="line">// riscvpipelined.sv</span>
<span class="line"></span>
<span class="line">// RISC-V pipelined processor</span>
<span class="line">// From Section 7.6 of Digital Design & Computer Architecture: RISC-V Edition</span>
<span class="line">// 27 April 2020</span>
<span class="line">// David_Harris@hmc.edu </span>
<span class="line">// Sarah.Harris@unlv.edu</span>
<span class="line"></span>
<span class="line">// run 210</span>
<span class="line">// Expect simulator to print "Simulation succeeded"</span>
<span class="line">// when the value 25 (0x19) is written to address 100 (0x64)</span>
<span class="line"></span>
<span class="line">// Pipelined implementation of RISC-V (RV32I)</span>
<span class="line">// User-level Instruction Set Architecture V2.2 (May 7, 2017)</span>
<span class="line">// Implements a subset of the base integer instructions:</span>
<span class="line">//    lw, sw</span>
<span class="line">//    add, sub, and, or, slt, </span>
<span class="line">//    addi, andi, ori, slti</span>
<span class="line">//    beq</span>
<span class="line">//    jal</span>
<span class="line">// Exceptions, traps, and interrupts not implemented</span>
<span class="line">// little-endian memory</span>
<span class="line"></span>
<span class="line">// 31 32-bit registers x1-x31, x0 hardwired to 0</span>
<span class="line">// R-Type instructions</span>
<span class="line">//   add, sub, and, or, slt</span>
<span class="line">//   INSTR rd, rs1, rs2</span>
<span class="line">//   Instr[31:25] = funct7 (funct7b5 & opb5 = 1 for sub, 0 for others)</span>
<span class="line">//   Instr[24:20] = rs2</span>
<span class="line">//   Instr[19:15] = rs1</span>
<span class="line">//   Instr[14:12] = funct3</span>
<span class="line">//   Instr[11:7]  = rd</span>
<span class="line">//   Instr[6:0]   = opcode</span>
<span class="line"></span>
<span class="line">// I-Type Instructions</span>
<span class="line">//   lw, I-type ALU (addi, andi, ori, slti)</span>
<span class="line">//   lw:         INSTR rd, imm(rs1)</span>
<span class="line">//   I-type ALU: INSTR rd, rs1, imm (12-bit signed)</span>
<span class="line">//   Instr[31:20] = imm[11:0]</span>
<span class="line">//   Instr[24:20] = rs2</span>
<span class="line">//   Instr[19:15] = rs1</span>
<span class="line">//   Instr[14:12] = funct3</span>
<span class="line">//   Instr[11:7]  = rd</span>
<span class="line">//   Instr[6:0]   = opcode</span>
<span class="line"></span>
<span class="line">// S-Type Instruction</span>
<span class="line">//   sw rs2, imm(rs1) (store rs2 into address specified by rs1 + immm)</span>
<span class="line">//   Instr[31:25] = imm[11:5] (offset[11:5])</span>
<span class="line">//   Instr[24:20] = rs2 (src)</span>
<span class="line">//   Instr[19:15] = rs1 (base)</span>
<span class="line">//   Instr[14:12] = funct3</span>
<span class="line">//   Instr[11:7]  = imm[4:0]  (offset[4:0])</span>
<span class="line">//   Instr[6:0]   = opcode</span>
<span class="line"></span>
<span class="line">// B-Type Instruction</span>
<span class="line">//   beq rs1, rs2, imm (PCTarget = PC + (signed imm x 2))</span>
<span class="line">//   Instr[31:25] = imm[12], imm[10:5]</span>
<span class="line">//   Instr[24:20] = rs2</span>
<span class="line">//   Instr[19:15] = rs1</span>
<span class="line">//   Instr[14:12] = funct3</span>
<span class="line">//   Instr[11:7]  = imm[4:1], imm[11]</span>
<span class="line">//   Instr[6:0]   = opcode</span>
<span class="line"></span>
<span class="line">// J-Type Instruction</span>
<span class="line">//   jal rd, imm  (signed imm is multiplied by 2 and added to PC, rd = PC+4)</span>
<span class="line">//   Instr[31:12] = imm[20], imm[10:1], imm[11], imm[19:12]</span>
<span class="line">//   Instr[11:7]  = rd</span>
<span class="line">//   Instr[6:0]   = opcode</span>
<span class="line"></span>
<span class="line">//   Instruction  opcode    funct3    funct7</span>
<span class="line">//   add          0110011   000       0000000</span>
<span class="line">//   sub          0110011   000       0100000</span>
<span class="line">//   and          0110011   111       0000000</span>
<span class="line">//   or           0110011   110       0000000</span>
<span class="line">//   slt          0110011   010       0000000</span>
<span class="line">//   addi         0010011   000       immediate</span>
<span class="line">//   andi         0010011   111       immediate</span>
<span class="line">//   ori          0010011   110       immediate</span>
<span class="line">//   slti         0010011   010       immediate</span>
<span class="line">//   beq          1100011   000       immediate</span>
<span class="line">//   lw	          0000011   010       immediate</span>
<span class="line">//   sw           0100011   010       immediate</span>
<span class="line">//   jal          1101111   immediate immediate</span>
<span class="line"></span>
<span class="line">/*</span>
<span class="line">add Done</span>
<span class="line">addi Done</span>
<span class="line">and Done</span>
<span class="line">andi Done</span>
<span class="line">auipc Jump instruction dont work</span>
<span class="line">beq Done</span>
<span class="line">bge Done</span>
<span class="line">bgeu Done</span>
<span class="line">blt Done</span>
<span class="line">bltu Done</span>
<span class="line">bne Done</span>
<span class="line">jal </span>
<span class="line">jalr </span>
<span class="line">lb Done</span>
<span class="line">lbu Done</span>
<span class="line">lh Done</span>
<span class="line">lhu Done</span>
<span class="line">lw Done</span>
<span class="line">lui Done</span>
<span class="line">or Done</span>
<span class="line">ori Done</span>
<span class="line">sb Done</span>
<span class="line">sh Done</span>
<span class="line">sll Done</span>
<span class="line">slt Done</span>
<span class="line">slli Done</span>
<span class="line">slti Done</span>
<span class="line">sltiu Done</span>
<span class="line">sltu Done</span>
<span class="line">sra Done</span>
<span class="line">srai Done</span>
<span class="line">srl Done</span>
<span class="line">srli Done</span>
<span class="line">sub Done</span>
<span class="line">sw Done</span>
<span class="line">xor Done</span>
<span class="line">xori Done</span>
<span class="line"></span>
<span class="line">*/</span>
<span class="line"></span>
<span class="line">module testbench();</span>
<span class="line"></span>
<span class="line">   logic        clk;</span>
<span class="line">   logic        reset;</span>
<span class="line"></span>
<span class="line">   logic [31:0] WriteData, DataAdr;</span>
<span class="line">   logic        MemWrite;</span>
<span class="line"></span>
<span class="line">   // instantiate device to be tested</span>
<span class="line">   top dut(clk, reset, WriteData, DataAdr, MemWrite);</span>
<span class="line"></span>
<span class="line">   initial</span>
<span class="line">     begin</span>
<span class="line">	string memfilename;</span>
<span class="line">        memfilename = {"../testing/auipc.memfile"};</span>
<span class="line">	$readmemh(memfilename, dut.imem.RAM);</span>
<span class="line">  $readmemh(memfilename, dut.dmem.RAM);</span>
<span class="line"></span>
<span class="line">     end</span>
<span class="line">   </span>
<span class="line">   // initialize test</span>
<span class="line">   initial</span>
<span class="line">     begin</span>
<span class="line">	reset <= 1; # 22; reset <= 0;</span>
<span class="line">     end</span>
<span class="line"></span>
<span class="line">   // generate clock to sequence tests</span>
<span class="line">   always</span>
<span class="line">     begin</span>
<span class="line">	clk <= 1; # 5; clk <= 0; # 5;</span>
<span class="line">     end</span>
<span class="line"></span>
<span class="line">/*   // check results</span>
<span class="line">   always @(negedge clk)</span>
<span class="line">     begin</span>
<span class="line">	if(MemWrite) begin</span>
<span class="line">           if(DataAdr === 100 & WriteData === 25) begin</span>
<span class="line">              $display("Simulation succeeded");</span>
<span class="line">              $stop;</span>
<span class="line">           end else if (DataAdr !== 96) begin</span>
<span class="line">              $display("Simulation failed");</span>
<span class="line">              $stop;</span>
<span class="line">           end</span>
<span class="line">	end</span>
<span class="line">     end*/</span>
<span class="line">endmodule</span>
<span class="line"></span>
<span class="line">/*module top(input  logic        clk, reset, </span>
<span class="line">           output logic [31:0] WriteDataM, DataAdrM, </span>
<span class="line">           output logic        MemWriteM);</span>
<span class="line"></span>
<span class="line">   logic [31:0] 	       PCF, InstrF, ReadDataM;</span>
<span class="line">   </span>
<span class="line">   // instantiate processor and memories</span>
<span class="line">   riscv rv32pipe (clk, reset, PCF, InstrF, MemWriteM, DataAdrM, </span>
<span class="line">		   WriteDataM, ReadDataM);</span>
<span class="line">   imem imem (PCF, InstrF);</span>
<span class="line">   dmem dmem (clk, MemWriteM, DataAdrM, WriteDataM, ReadDataM);</span>
<span class="line">   </span>
<span class="line">endmodule*/</span>
<span class="line"></span>
<span class="line">module riscv(input  logic        clk, reset,</span>
<span class="line">             output logic [31:0] PCF,</span>
<span class="line">             input logic [31:0]  InstrF,</span>
<span class="line">             output logic 	 MemWriteM,</span>
<span class="line">             output logic [31:0] ALUResultM, WriteDataM,</span>
<span class="line">             input logic [31:0]  ReadDataM);</span>
<span class="line"></span>
<span class="line">   logic [6:0] 			 opD;</span>
<span class="line">   logic [2:0] 			 funct3D, funct3M, funct3E;</span>
<span class="line">   logic 			 funct7b5D;</span>
<span class="line">   logic [2:0] 			 ImmSrcD;</span>
<span class="line">   logic 			 ZeroE, NegativeE, CarryE, OverflowE;</span>
<span class="line">   logic 			 PCSrcE, PCSrcNextE;</span>
<span class="line">   logic [3:0] 			 ALUControlE;</span>
<span class="line">   logic [1:0] ALUSrcE;</span>
<span class="line">   logic 			 ResultSrcEb0;</span>
<span class="line">   logic 			 RegWriteM;</span>
<span class="line">   logic [1:0] 			 ResultSrcW;</span>
<span class="line">   logic 			 RegWriteW;</span>
<span class="line"></span>
<span class="line">   logic [1:0] 			 ForwardAE, ForwardBE;</span>
<span class="line">   logic 			 StallF, StallD, FlushD, FlushE;</span>
<span class="line"></span>
<span class="line">   logic [4:0] 			 Rs1D, Rs2D, Rs1E, Rs2E, RdE, RdM, RdW;</span>
<span class="line">   logic [31:0] dpReadDataM, dpWriteDataM;</span>
<span class="line">   </span>
<span class="line">   controller c(clk, reset,</span>
<span class="line">            opD, funct3D, funct3E, funct7b5D, ImmSrcD,</span>
<span class="line">            FlushE, ZeroE, NegativeE, CarryE, OverflowE, PCSrcE, PCSrcNextE, ALUControlE, ALUSrcE, ResultSrcEb0,</span>
<span class="line">            MemWriteM, RegWriteM, </span>
<span class="line">            RegWriteW, ResultSrcW, funct3M);</span>
<span class="line"></span>
<span class="line">   datapath dp(clk, reset,</span>
<span class="line">           StallF, PCF, InstrF,</span>
<span class="line">           opD, funct3D, funct7b5D, StallD, FlushD, ImmSrcD,</span>
<span class="line">           FlushE, ForwardAE, ForwardBE, PCSrcE, PCSrcNextE, ALUControlE, ALUSrcE, ZeroE, NegativeE, CarryE, OverflowE,</span>
<span class="line">           MemWriteM, dpWriteDataM, ALUResultM, ReadDataM,</span>
<span class="line">           RegWriteW, ResultSrcW,</span>
<span class="line">           Rs1D, Rs2D, Rs1E, Rs2E, RdE, RdM, RdW);</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">   hazard  hu(Rs1D, Rs2D, Rs1E, Rs2E, RdE, RdM, RdW,</span>
<span class="line">              PCSrcE,PCSrcNextE, ResultSrcEb0, RegWriteM, RegWriteW,</span>
<span class="line">              ForwardAE, ForwardBE, StallF, StallD, FlushD, FlushE);			</span>
<span class="line"></span>
<span class="line">always_comb</span>
<span class="line">  case(funct3M)</span>
<span class="line">    // Store byte (sb)</span>
<span class="line">    3'b000: begin</span>
<span class="line">      case(ALUResultM[1:0])</span>
<span class="line">        2'b00: WriteDataM = {ReadDataM[31:8], dpWriteDataM[7:0]};</span>
<span class="line">        2'b01: WriteDataM = {ReadDataM[31:16], dpWriteDataM[7:0], ReadDataM[7:0]};</span>
<span class="line">        2'b10: WriteDataM = {ReadDataM[31:24], dpWriteDataM[7:0], ReadDataM[15:0]};</span>
<span class="line">        2'b11: WriteDataM = {dpWriteDataM[7:0], ReadDataM[23:0]};</span>
<span class="line">      endcase</span>
<span class="line">    end</span>
<span class="line">    // Store halfword (sh)</span>
<span class="line">    3'b001: begin</span>
<span class="line">      case(ALUResultM[1])</span>
<span class="line">        1'b0: WriteDataM = {ReadDataM[31:16], dpWriteDataM[15:0]};</span>
<span class="line">        1'b1: WriteDataM = {dpWriteDataM[15:0], ReadDataM[15:0]};</span>
<span class="line">      endcase</span>
<span class="line">    end</span>
<span class="line">    // Store word (sw)</span>
<span class="line">    default: WriteDataM = dpWriteDataM;</span>
<span class="line">  endcase</span>
<span class="line"></span>
<span class="line">endmodule</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">module controller(input  logic        clk, reset,</span>
<span class="line">                  // Decode stage control signals</span>
<span class="line">                  input logic [6:0]   opD,</span>
<span class="line">                  input logic [2:0]   funct3D, funct3E,</span>
<span class="line">                  input logic         funct7b5D,</span>
<span class="line">                  output logic [2:0]  ImmSrcD,</span>
<span class="line">                  // Execute stage control signals</span>
<span class="line">                  input logic         FlushE, </span>
<span class="line">                  input logic         ZeroE, NegativeE, CarryE, OverflowE,</span>
<span class="line">                  output logic        PCSrcE, // for datapath and Hazard Unit</span>
<span class="line">                  output logic        PCSrcNextE, // for jalr</span>
<span class="line">                  output logic [3:0]  ALUControlE, </span>
<span class="line">                  output logic [1:0]  ALUSrcE,</span>
<span class="line">                  output logic        ResultSrcEb0, // for Hazard Unit</span>
<span class="line">                  // Memory stage control signals</span>
<span class="line">                  output logic        MemWriteM,</span>
<span class="line">                  output logic        RegWriteM, // for Hazard Unit                  </span>
<span class="line">                  // Writeback stage control signals</span>
<span class="line">                  output logic        RegWriteW, // for datapath and Hazard Unit</span>
<span class="line">                  output logic [1:0]  ResultSrcW,</span>
<span class="line">                  output logic [2:0]  funct3M);</span>
<span class="line">   // pipelined control signals</span>
<span class="line">   logic 			     RegWriteD, RegWriteE;</span>
<span class="line">   logic [1:0] 			     ResultSrcD, ResultSrcE, ResultSrcM;</span>
<span class="line">   logic 			     MemWriteD, MemWriteE;</span>
<span class="line">   logic 			     JumpD, JumpE;</span>
<span class="line">   logic 			     BranchD, BranchE, BranchTakenE;</span>
<span class="line">   logic [1:0] 			     ALUOpD;</span>
<span class="line">   logic [3:0] 			     ALUControlD;</span>
<span class="line">   logic [1:0]			     ALUSrcD;</span>
<span class="line">   logic                Memstrobe;</span>
<span class="line">   // Fetching Instructions</span>
<span class="line">   </span>
<span class="line">   // Decode stage logic</span>
<span class="line">   maindec md(opD, ResultSrcD, MemWriteD, BranchD,</span>
<span class="line">              ALUSrcD, RegWriteD, JumpD, Memstrobe, ImmSrcD, ALUOpD);</span>
<span class="line">   aludec  ad(opD[5], funct3D, funct7b5D, ALUOpD, ALUControlD);</span>
<span class="line">   </span>
<span class="line">   // Execute stage pipeline control register and logic</span>
<span class="line">   floprc #(15) controlregE(clk, reset, FlushE,</span>
<span class="line">                        {RegWriteD, ResultSrcD, MemWriteD, JumpD, BranchD, ALUControlD, ALUSrcD, funct3D},</span>
<span class="line">                        {RegWriteE, ResultSrcE, MemWriteE, JumpE, BranchE, ALUControlE, ALUSrcE, funct3E});</span>
<span class="line"></span>
<span class="line">always_comb</span>
<span class="line">  case(funct3E)</span>
<span class="line">    3'b000: BranchTakenE = ZeroE;                    // beq =</span>
<span class="line">    3'b001: BranchTakenE = ~ZeroE;                   // bne !=</span>
<span class="line">    3'b100: BranchTakenE = (NegativeE ^ OverflowE);  // blt </span>
<span class="line">    3'b101: BranchTakenE = ~(NegativeE ^ OverflowE); // bge >=</span>
<span class="line">    3'b110: BranchTakenE = ~CarryE;                  // bltu < unsigned</span>
<span class="line">    3'b111: BranchTakenE = CarryE;                   // bgeu >= unsigned</span>
<span class="line">    default: BranchTakenE = 1'b0;</span>
<span class="line">  endcase</span>
<span class="line"></span>
<span class="line">   assign PCSrcE = (BranchE & BranchTakenE) | JumpE;</span>
<span class="line">   assign PCSrcNextE = JumpE & ALUSrcE;</span>
<span class="line">   assign ResultSrcEb0 = ResultSrcE[0];</span>
<span class="line">   </span>
<span class="line">   // Memory stage pipeline control register</span>
<span class="line">   flopr #(7) controlregM(clk, reset,</span>
<span class="line">                      {RegWriteE, ResultSrcE, MemWriteE, funct3E},</span>
<span class="line">                      {RegWriteM, ResultSrcM, MemWriteM, funct3M});</span>
<span class="line">   </span>
<span class="line">   // Writeback stage pipeline control register</span>
<span class="line">   flopr #(3) controlregW(clk, reset,</span>
<span class="line">                          {RegWriteM, ResultSrcM},</span>
<span class="line">                          {RegWriteW, ResultSrcW});     </span>
<span class="line">endmodule</span>
<span class="line"></span>
<span class="line">module maindec (input  logic [6:0] op,</span>
<span class="line">		output logic [1:0] ResultSrc,</span>
<span class="line">		output logic 	   MemWrite,</span>
<span class="line">		output logic 	   Branch,</span>
<span class="line">		output logic [1:0]  ALUSrc,</span>
<span class="line">		output logic 	   RegWrite, Jump, MemStrobe,</span>
<span class="line">		output logic [2:0] ImmSrc,</span>
<span class="line">		output logic [1:0] ALUOp);</span>
<span class="line">   </span>
<span class="line">	logic [13:0] 		   controls;</span>
<span class="line">   </span>
<span class="line">   assign {RegWrite, ImmSrc, ALUSrc, MemWrite,</span>
<span class="line">	   ResultSrc, Branch, ALUOp, Jump ,MemStrobe} = controls;</span>
<span class="line">   </span>
<span class="line">   always_comb</span>
<span class="line">     case(op)</span>
<span class="line">       // RegWrite_ImmSrc_ALUSrc_MemWrite_ResultSrc_Branch_ALUOp_Jump_MemStrobe</span>
<span class="line">       7'b0000011: controls = 14'b1_000_01_0_11_0_00_0_1; // load</span>
<span class="line">       7'b0100011: controls = 14'b0_001_01_1_01_0_00_0_1; // save</span>
<span class="line">       7'b0110011: controls = 14'b1_xxx_00_0_00_0_10_0_0; // R–type</span>
<span class="line">       7'b1100011: controls = 14'b0_010_00_0_00_1_01_0_0; // B-Type</span>
<span class="line">       7'b0010011: controls = 14'b1_000_01_0_00_0_10_0_0; // I–type ALU</span>
<span class="line">       7'b1101111: controls = 14'b1_011_00_0_10_0_00_1_0; // Jal</span>
<span class="line">       7'b1100111: controls = 14'b1_000_01_0_10_0_00_1_0; // jalr   </span>
<span class="line">       7'b0010111: controls = 14'b1_100_11_0_00_0_00_0_0; // auipc    </span>
<span class="line">       7'b0110111: controls = 14'b1_100_01_0_00_0_11_0_0; // lui      </span>
<span class="line"></span>
<span class="line">       default: controls = 14'bx_xxx_xx_x_xx_x_xx_x_x; // ???</span>
<span class="line">     endcase // case (op)</span>
<span class="line">   </span>
<span class="line">endmodule // maindec</span>
<span class="line"></span>
<span class="line">module aludec (input  logic     opb5,</span>
<span class="line">	       input  logic [2:0]   funct3,</span>
<span class="line">	       input  logic 	    funct7b5,</span>
<span class="line">	       input  logic [1:0]   ALUOp,</span>
<span class="line">	       output logic [3:0]   ALUControl);</span>
<span class="line">   </span>
<span class="line">   logic 			  RtypeSub;</span>
<span class="line">   </span>
<span class="line">   assign RtypeSub = funct7b5 & opb5; // TRUE for R–type subtract</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">   always_comb</span>
<span class="line">     case(ALUOp)</span>
<span class="line">        2'b00: ALUControl = 4'b0000; // addition</span>
<span class="line">        2'b01: ALUControl = 4'b0001; // subtraction</span>
<span class="line">        2'b11: ALUControl = 4'b1110; // lui</span>
<span class="line">        default: case(funct3) // R–type or I–type ALU</span>
<span class="line">            3'b000: if (RtypeSub)</span>
<span class="line">                         ALUControl = 4'b0001; // sub</span>
<span class="line">                    else</span>
<span class="line">                         ALUControl = 4'b0000; // add, addi</span>
<span class="line">            3'b010: if (!RtypeSub) // I type set less than</span>
<span class="line">                         ALUControl = 4'b0101; // slt, slti</span>
<span class="line">                    else</span>
<span class="line">                         if (!funct7b5)</span>
<span class="line">                             ALUControl = 4'b0101; // slt</span>
<span class="line">                         else</span>
<span class="line">                             ALUControl = 4'b1010; // sgt</span>
<span class="line">            3'b110: ALUControl = 4'b0011; // or, ori</span>
<span class="line">            3'b111: ALUControl = 4'b0010; // and, andi</span>
<span class="line">            3'b100: ALUControl = 4'b0100; // xor, xori</span>
<span class="line">            3'b101: if (funct7b5)</span>
<span class="line">                         ALUControl = 4'b0111; // sra, srai</span>
<span class="line">                    else</span>
<span class="line">                         ALUControl = 4'b0110; // srl, srli</span>
<span class="line">            3'b001: ALUControl = 4'b1000; // sll, slli</span>
<span class="line">            3'b011: if (!RtypeSub) // I type</span>
<span class="line">                         ALUControl = 4'b1001; // sltiu</span>
<span class="line">                    else // R type</span>
<span class="line">                         if (!funct7b5)</span>
<span class="line">                             ALUControl = 4'b1001; // sltu</span>
<span class="line">                         else</span>
<span class="line">                             ALUControl = 4'b1100;</span>
<span class="line">            default: ALUControl = 4'bxxxx; // ???</span>
<span class="line">        endcase // case (funct3)</span>
<span class="line">     endcase // case (ALUOp)</span>
<span class="line"></span>
<span class="line">endmodule // aludec</span>
<span class="line"></span>
<span class="line">module datapath(input logic clk, reset,</span>
<span class="line">                // Fetch stage signals</span>
<span class="line">                input logic         StallF,</span>
<span class="line">                output logic [31:0] PCF,</span>
<span class="line">                input logic [31:0]  InstrF,</span>
<span class="line">                // Decode stage signals</span>
<span class="line">                output logic [6:0]  opD,</span>
<span class="line">                output logic [2:0]  funct3D,</span>
<span class="line">                output logic        funct7b5D,</span>
<span class="line">                input logic         StallD, FlushD,</span>
<span class="line">                input logic [2:0]   ImmSrcD,</span>
<span class="line">                // Execute stage signals</span>
<span class="line">                input logic         FlushE,</span>
<span class="line">                input logic [1:0]   ForwardAE, ForwardBE,</span>
<span class="line">                input logic         PCSrcE,</span>
<span class="line">                input logic         PCSrcNextE,</span>
<span class="line">                input logic [3:0]   ALUControlE,</span>
<span class="line">                input logic [1:0]   ALUSrcE,</span>
<span class="line">                output logic        ZeroE, NegativeE, CarryE, OverflowE,</span>
<span class="line">                // Memory stage signals</span>
<span class="line">                input logic         MemWriteM,</span>
<span class="line">                output logic [31:0] dpWriteDataM, ALUResultM,</span>
<span class="line">                input logic [31:0]  ReadDataM,</span>
<span class="line">                // Writeback stage signals</span>
<span class="line">                input logic         RegWriteW,</span>
<span class="line">                input logic [1:0]   ResultSrcW,</span>
<span class="line">                // Hazard Unit signals</span>
<span class="line">                output logic [4:0]  Rs1D, Rs2D, Rs1E, Rs2E,</span>
<span class="line">                output logic [4:0]  RdE, RdM, RdW);</span>
<span class="line">   // Fetch stage signals</span>
<span class="line">   logic [31:0] PCNextTemp, PCNextF, PCPlus4F;</span>
<span class="line">   // Decode stage signals</span>
<span class="line">   logic [31:0] InstrD;</span>
<span class="line">   logic [31:0] PCD, PCPlus4D;</span>
<span class="line">   logic [31:0] RD1D, RD2D;</span>
<span class="line">   logic [31:0] ImmExtD;</span>
<span class="line">   logic [4:0] RdD;</span>
<span class="line">   // Execute stage signals</span>
<span class="line">   logic [31:0] RD1E, RD2E;</span>
<span class="line">   logic [31:0] PCE, ImmExtE;</span>
<span class="line">   logic [31:0] SrcAE, SrcBE, RegOutAE;</span>
<span class="line">   logic [31:0] ALUResultE;</span>
<span class="line">   logic [31:0] WriteDataE;</span>
<span class="line">   logic [31:0] PCPlus4E;</span>
<span class="line">   logic [31:0] PCTargetE;</span>
<span class="line">   // Memory stage signals</span>
<span class="line">   logic [31:0] PCPlus4M;</span>
<span class="line">   // Writeback stage signals</span>
<span class="line">   logic [31:0] ALUResultW;</span>
<span class="line">   logic [31:0] ReadDataW;</span>
<span class="line">   logic [31:0] PCPlus4W;</span>
<span class="line">   logic [31:0] ResultW;</span>
<span class="line">   logic [31:0] ResultLoad;</span>
<span class="line"></span>
<span class="line">   // Fetch stage pipeline register and logic</span>
<span class="line">   mux2 #(32) pcmux(PCPlus4F, PCTargetE, PCSrcE, PCNextTemp);</span>
<span class="line">   mux2 #(32) pcmux2(PCNextTemp, ALUResultE, PCSrcNextE, PCNextF);</span>
<span class="line">   flopenr #(32) pcreg(clk, reset, ~StallF, PCNextF, PCF);</span>
<span class="line">   adder pcadd(PCF, 32'h4, PCPlus4F);</span>
<span class="line"></span>
<span class="line">   // Decode stage pipeline register and logic</span>
<span class="line">   flopenrc #(96) regD(clk, reset, FlushD, ~StallD,</span>
<span class="line">                       {InstrF, PCF, PCPlus4F},</span>
<span class="line">                       {InstrD, PCD, PCPlus4D});</span>
<span class="line">   assign opD       = InstrD[6:0];</span>
<span class="line">   assign funct3D   = InstrD[14:12];</span>
<span class="line">   assign funct7b5D = InstrD[30];</span>
<span class="line">   assign Rs1D      = InstrD[19:15];</span>
<span class="line">   assign Rs2D      = InstrD[24:20];</span>
<span class="line">   assign RdD       = InstrD[11:7];</span>
<span class="line"></span>
<span class="line">   regfile        rf(clk, RegWriteW, Rs1D, Rs2D, RdW, ResultW, RD1D, RD2D);</span>
<span class="line">   extend         ext(InstrD[31:7], ImmSrcD, ImmExtD);</span>
<span class="line"></span>
<span class="line">   // Execute stage pipeline register and logic</span>
<span class="line">   floprc #(175) regE(clk, reset, FlushE,</span>
<span class="line">                      {RD1D, RD2D, PCD, Rs1D, Rs2D, RdD, ImmExtD, PCPlus4D},</span>
<span class="line">                      {RD1E, RD2E, PCE, Rs1E, Rs2E, RdE, ImmExtE, PCPlus4E});</span>
<span class="line"></span>
<span class="line">   mux3   #(32)  faemux(RD1E, ResultW, ALUResultM, ForwardAE, RegOutAE);</span>
<span class="line">   mux3   #(32)  fbemux(RD2E, ResultW, ALUResultM, ForwardBE, WriteDataE);</span>
<span class="line">   mux2   #(32)  srcamux(RegOutAE, PCE, ALUSrcE[1], SrcAE);</span>
<span class="line">   mux2   #(32)  srcbmux(WriteDataE, ImmExtE, ALUSrcE[0], SrcBE);</span>
<span class="line">   alu           alu(SrcAE, SrcBE, ALUControlE, ALUResultE, ZeroE, NegativeE, CarryE, OverflowE);</span>
<span class="line">   adder         branchadd(ImmExtE, PCE, PCTargetE);</span>
<span class="line"></span>
<span class="line">   // Memory stage pipeline register</span>
<span class="line">   flopr  #(101) regM(clk, reset,</span>
<span class="line">                  {ALUResultE, WriteDataE, RdE, PCPlus4E},</span>
<span class="line">                  {ALUResultM, dpWriteDataM, RdM, PCPlus4M});</span>
<span class="line"></span>
<span class="line">   // Writeback stage pipeline register and logic</span>
<span class="line">   flopr  #(101) regW(clk, reset,</span>
<span class="line">                      {ALUResultM, ReadDataM, RdM, PCPlus4M},</span>
<span class="line">                      {ALUResultW, ReadDataW, RdW, PCPlus4W});</span>
<span class="line">   mux4 #(32) resultmux(ALUResultW, ReadDataW, PCPlus4W, ResultLoad, ResultSrcW, ResultW);</span>
<span class="line">   loadextend load (ALUResultW, ReadDataW, funct3D, ResultLoad);</span>
<span class="line">   // If memwrite  == true go to store extend</span>
<span class="line">endmodule</span>
<span class="line"></span>
<span class="line">// Hazard Unit: forward, stall, and flush</span>
<span class="line">module hazard(input  logic [4:0] Rs1D, Rs2D, Rs1E, Rs2E, RdE, RdM, RdW,</span>
<span class="line">              input logic        PCSrcE, PCSrcNextE, ResultSrcEb0,</span>
<span class="line">              input logic        RegWriteM, RegWriteW,</span>
<span class="line">              output logic [1:0] ForwardAE, ForwardBE,</span>
<span class="line">              output logic       StallF, StallD, FlushD, FlushE);</span>
<span class="line"></span>
<span class="line">   logic lwStallD;</span>
<span class="line"></span>
<span class="line">   // forwarding logic</span>
<span class="line">   always_comb begin</span>
<span class="line">      ForwardAE = 2'b00;</span>
<span class="line">      ForwardBE = 2'b00;</span>
<span class="line">      if (Rs1E != 5'b0)</span>
<span class="line">         if      ((Rs1E == RdM) & RegWriteM) ForwardAE = 2'b10;</span>
<span class="line">         else if ((Rs1E == RdW) & RegWriteW) ForwardAE = 2'b01;</span>
<span class="line"></span>
<span class="line">      if (Rs2E != 5'b0)</span>
<span class="line">         if      ((Rs2E == RdM) & RegWriteM) ForwardBE = 2'b10;</span>
<span class="line">         else if ((Rs2E == RdW) & RegWriteW) ForwardBE = 2'b01;</span>
<span class="line">   end</span>
<span class="line"></span>
<span class="line">   // stalls and flushes</span>
<span class="line">   assign lwStallD = ResultSrcEb0 & ((Rs1D == RdE) | (Rs2D == RdE));</span>
<span class="line">   assign StallD = lwStallD;</span>
<span class="line">   assign StallF = lwStallD;</span>
<span class="line">   assign FlushD = PCSrcE | PCSrcNextE;</span>
<span class="line">   assign FlushE = lwStallD | PCSrcE | PCSrcNextE;</span>
<span class="line">endmodule</span>
<span class="line"></span>
<span class="line">module regfile(input  logic        clk,</span>
<span class="line">               input logic         we3,</span>
<span class="line">               input logic [ 4:0]  a1, a2, a3,</span>
<span class="line">               input logic [31:0]  wd3,</span>
<span class="line">               output logic [31:0] rd1, rd2);</span>
<span class="line"></span>
<span class="line">   logic [31:0] rf[31:0];</span>
<span class="line"></span>
<span class="line">   // three ported register file</span>
<span class="line">   // read two ports combinationally (A1/RD1, A2/RD2)</span>
<span class="line">   // write third port on rising edge of clock (A3/WD3/WE3)</span>
<span class="line">   // write occurs on falling edge of clock</span>
<span class="line">   // register 0 hardwired to 0</span>
<span class="line"></span>
<span class="line">   always_ff @(negedge clk)</span>
<span class="line">     if (we3) rf[a3] <= wd3;</span>
<span class="line"></span>
<span class="line">   assign rd1 = (a1 != 0) ? rf[a1] : 0;</span>
<span class="line">   assign rd2 = (a2 != 0) ? rf[a2] : 0;</span>
<span class="line">endmodule</span>
<span class="line"></span>
<span class="line">module adder(input  [31:0] a, b,</span>
<span class="line">             output [31:0] y);</span>
<span class="line"></span>
<span class="line">   assign y = a + b;</span>
<span class="line">endmodule</span>
<span class="line"></span>
<span class="line">module extend (input  logic [31:7] instr,</span>
<span class="line">               input  logic [2:0]  immsrc,</span>
<span class="line">               output logic [31:0] immext);</span>
<span class="line"></span>
<span class="line">   always_comb</span>
<span class="line">     case(immsrc)</span>
<span class="line">       // I−type</span>
<span class="line">       3'b000:  immext = {{20{instr[31]}}, instr[31:20]};</span>
<span class="line">       // S−type (stores)</span>
<span class="line">       3'b001:  immext = {{20{instr[31]}}, instr[31:25], instr[11:7]};</span>
<span class="line">       // B−type (branches)</span>
<span class="line">       3'b010:  immext = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};</span>
<span class="line">       // J−type (jal)</span>
<span class="line">       3'b011:  immext = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};</span>
<span class="line">        // U−type (lui, auipc)</span>
<span class="line">       3'b100: immext = {instr[31:12], 12'b0};</span>
<span class="line">       default: immext = 32'bx; // undefined</span>
<span class="line">     endcase // case (immsrc)</span>
<span class="line"></span>
<span class="line">endmodule // extend</span>
<span class="line"></span>
<span class="line">module loadextend (input logic [31:0] ALUResult, ReadData,</span>
<span class="line">                     input logic [2:0] funct3,</span>
<span class="line">                     output logic [31:0] ResultLoad);</span>
<span class="line"></span>
<span class="line">     logic [1:0]    loadchunk;</span>
<span class="line"></span>
<span class="line">     assign loadchunk = ALUResult[1:0];</span>
<span class="line"></span>
<span class="line">     always_comb</span>
<span class="line">        case(funct3)</span>
<span class="line">         3'b000: case(loadchunk) // lb</span>
<span class="line">           2'b00: ResultLoad = {{24{ReadData[7]}}, ReadData[7:0]};</span>
<span class="line">           2'b01: ResultLoad = {{24{ReadData[15]}}, ReadData[15:8]};</span>
<span class="line">           2'b10: ResultLoad = {{24{ReadData[23]}}, ReadData[23:16]};</span>
<span class="line">           2'b11: ResultLoad = {{24{ReadData[31]}}, ReadData[31:24]};</span>
<span class="line">           default: ResultLoad = 32'bx;</span>
<span class="line">           endcase</span>
<span class="line">         3'b001:  case(loadchunk[1]) // lh</span>
<span class="line">             1'b0:  ResultLoad = {{16{ReadData[15]}}, ReadData[15:0]};</span>
<span class="line">             1'b1:  ResultLoad = {{16{ReadData[31]}}, ReadData[31:16]};</span>
<span class="line">             default: ResultLoad = 32'bx;</span>
<span class="line">             endcase</span>
<span class="line">         3'b010:  ResultLoad = ReadData; // lw</span>
<span class="line">         3'b100: case(loadchunk) // lbu</span>
<span class="line">           2'b00: ResultLoad = {{24{0}}, ReadData[7:0]};</span>
<span class="line">           2'b01: ResultLoad = {{24{0}}, ReadData[15:8]};</span>
<span class="line">           2'b10: ResultLoad = {{24{0}}, ReadData[23:16]};</span>
<span class="line">           2'b11: ResultLoad = {{24{0}}, ReadData[31:24]};</span>
<span class="line">           default: ResultLoad = 32'bx;</span>
<span class="line">           endcase</span>
<span class="line">         3'b101:  case(loadchunk[1]) // lhu</span>
<span class="line">             1'b0:  ResultLoad = {{16{0}}, ReadData[15:0]};</span>
<span class="line">             1'b1:  ResultLoad = {{16{0}}, ReadData[31:16]};</span>
<span class="line">             default: ResultLoad = 32'bx;</span>
<span class="line">             endcase</span>
<span class="line">         default: ResultLoad = 32'bx;</span>
<span class="line">         endcase</span>
<span class="line"></span>
<span class="line">endmodule // loadextend</span>
<span class="line"></span>
<span class="line">/* module store (input logic [31:0] ALUResult, Result,</span>
<span class="line">               input logic Memwrite,</span>
<span class="line">               input logic [2:0] funct3,</span>
<span class="line">               output logic [31:0] ResultStore);</span>
<span class="line"></span>
<span class="line">     logic [1:0]    storechunk;</span>
<span class="line"></span>
<span class="line">     assign storechunk = ALUResult[1:0];</span>
<span class="line"></span>
<span class="line"> if(Memwrite){</span>
<span class="line">     always_comb</span>
<span class="line">        case(funct3)</span>
<span class="line">         3'b000: case(storechunk) // sb</span>
<span class="line">           2'b00: ResultStore = {{{Result[31:8]}}, Result[7:0]};</span>
<span class="line">           2'b01: ResultStore = {{{Result[31:16]}}, Result[7:0], Result[7:0]};</span>
<span class="line">           2'b10: ResultStore = {{{Result[31:24]}}, Result[7:0], Result[15:0]};</span>
<span class="line">           2'b11: ResultStore = {{{Result[7:0]}}, Result[23:0]};</span>
<span class="line">           default: ResultStore = 32'bx;</span>
<span class="line">           endcase</span>
<span class="line">         3'b001:  case(storechunk[1]) // sh</span>
<span class="line">             1'b0:  ResultStore = {{{Result[31:16]}}, Result[15:0]};</span>
<span class="line">             1'b1:  ResultStore = {{{Result[31:16]}}, Result[15:0]};</span>
<span class="line">             default: ResultStore = 32'bx;</span>
<span class="line">             endcase</span>
<span class="line">         3'b010:  ResultStore = Result; // sw</span>
<span class="line">         default: ResultStore = 32'bx;</span>
<span class="line">         endcase</span>
<span class="line"> }</span>
<span class="line"></span>
<span class="line">endmodule // loadextend */</span>
<span class="line"></span>
<span class="line">module flopr #(parameter WIDTH = 8)</span>
<span class="line">   (input  logic             clk, reset,</span>
<span class="line">    input logic [WIDTH-1:0]  d,</span>
<span class="line">    output logic [WIDTH-1:0] q);</span>
<span class="line"></span>
<span class="line">   always_ff @(posedge clk, posedge reset)</span>
<span class="line">     if (reset) q <= 0;</span>
<span class="line">     else       q <= d;</span>
<span class="line">endmodule</span>
<span class="line"></span>
<span class="line">module flopenr #(parameter WIDTH = 8)</span>
<span class="line">   (input  logic             clk, reset, en,</span>
<span class="line">    input logic [WIDTH-1:0]  d,</span>
<span class="line">    output logic [WIDTH-1:0] q);</span>
<span class="line"></span>
<span class="line">   always_ff @(posedge clk, posedge reset)</span>
<span class="line">     if (reset)   q <= 0;</span>
<span class="line">     else if (en) q <= d;</span>
<span class="line">endmodule</span>
<span class="line"></span>
<span class="line">module flopenrc #(parameter WIDTH = 8)</span>
<span class="line">   (input  logic             clk, reset, clear, en,</span>
<span class="line">    input logic [WIDTH-1:0]  d,</span>
<span class="line">    output logic [WIDTH-1:0] q);</span>
<span class="line"></span>
<span class="line">   always_ff @(posedge clk, posedge reset)</span>
<span class="line">     if (reset)   q <= 0;</span>
<span class="line">     else if (en)</span>
<span class="line">       if (clear) q <= 0;</span>
<span class="line">       else       q <= d;</span>
<span class="line">endmodule</span>
<span class="line"></span>
<span class="line">module floprc #(parameter WIDTH = 8)</span>
<span class="line">   (input  logic clk,</span>
<span class="line">    input logic              reset,</span>
<span class="line">    input logic              clear,</span>
<span class="line">    input logic [WIDTH-1:0]  d,</span>
<span class="line">    output logic [WIDTH-1:0] q);</span>
<span class="line"></span>
<span class="line">   always_ff @(posedge clk, posedge reset)</span>
<span class="line">     if (reset) q <= 0;</span>
<span class="line">     else</span>
<span class="line">       if (clear) q <= 0;</span>
<span class="line">       else       q <= d;</span>
<span class="line">endmodule</span>
<span class="line"></span>
<span class="line">module mux2 #(parameter WIDTH = 8)</span>
<span class="line">   (input  logic [WIDTH-1:0] d0, d1,</span>
<span class="line">    input logic              s,</span>
<span class="line">    output logic [WIDTH-1:0] y);</span>
<span class="line"></span>
<span class="line">   assign y = s ? d1 : d0;</span>
<span class="line">endmodule</span>
<span class="line"></span>
<span class="line">module mux3 #(parameter WIDTH = 8)</span>
<span class="line">   (input  logic [WIDTH-1:0] d0, d1, d2,</span>
<span class="line">    input logic [1:0]        s,</span>
<span class="line">    output logic [WIDTH-1:0] y);</span>
<span class="line"></span>
<span class="line">   assign y = s[1] ? d2 : (s[0] ? d1 : d0);</span>
<span class="line">endmodule</span>
<span class="line"></span>
<span class="line">module mux4 # (parameter WIDTH = 8)</span>
<span class="line">            (input logic [WIDTH-1:0] d0, d1, d2, d3,</span>
<span class="line">             input logic [1:0] s,</span>
<span class="line">             output logic [WIDTH-1:0] y);</span>
<span class="line"></span>
<span class="line">    assign y = (s[1] ? (s[0] ? d3 : d2) : (s[0] ? d1 : d0));</span>
<span class="line"></span>
<span class="line">endmodule</span>
<span class="line"></span>
<span class="line">/*module imem (input  logic [31:0] a,</span>
<span class="line">             output logic [31:0] rd);</span>
<span class="line"></span>
<span class="line">   logic [31:0] RAM[2047:0];</span>
<span class="line"></span>
<span class="line">   assign rd = RAM[a[31:2]]; // word aligned</span>
<span class="line"></span>
<span class="line">endmodule // imem</span>

<span class="line"></span>
<span class="line">module dmem (input  logic        clk, we,</span>
<span class="line">             input  logic [31:0] a, wd,</span>
<span class="line">             output logic [31:0] rd);</span>
<span class="line"></span>
<span class="line">   logic [31:0] RAM[2047:0];</span>
<span class="line"></span>
<span class="line">   assign rd = RAM[a[31:2]]; // word aligned</span>
<span class="line">   always_ff @(posedge clk)</span>
<span class="line">     if (we) RAM[a[31:2]] <= wd;</span>
<span class="line"></span>
<span class="line">endmodule // dmem*/</span>
<span class="line"></span>
<span class="line">module alu (input  logic [31:0] a, b,</span>
<span class="line">            input  logic [3:0]  alucontrol,</span>
<span class="line">            output logic [31:0] result,</span>
<span class="line">            output logic         zero, negative, carry, overflow);</span>
<span class="line"></span>
<span class="line">   logic [31:0] condinvb, sum, xorOut, sltuOut;</span>
<span class="line">   logic [32:0] fullsum;</span>
<span class="line">   logic        Cout;</span>
<span class="line">   logic        isAddSub;       // true when is add or subtract operation</span>
<span class="line"></span>
<span class="line">   assign condinvb = alucontrol[0] ? ~b : b;</span>
<span class="line">   assign fullsum = a + condinvb + alucontrol[0];</span>
<span class="line">   assign sum = {fullsum[31:0]};</span>
<span class="line">   assign isAddSub = ~alucontrol[2] & ~alucontrol[1] |</span>
<span class="line">                     ~alucontrol[1] & alucontrol[0]  |</span>
<span class="line">                     alucontrol[2] & alucontrol[1] & alucontrol[0];</span>
<span class="line"></span>
<span class="line">   always_comb</span>
<span class="line">     case (alucontrol)</span>
<span class="line">       4'b0000:  result = sum;         // add</span>
<span class="line">       4'b0001:  result = sum;         // subtract</span>
<span class="line">       4'b0010:  result = a & b;       // and</span>
<span class="line">       4'b0011:  result = a | b;       // or</span>
<span class="line">       4'b0101:  result = sum[31] ^ overflow; // slt</span>
<span class="line">       4'b0110:  result = a >> unsigned'(b[4:0]);      // srl</span>
<span class="line">       4'b0111:  result = $signed(a) >>> unsigned'(b[4:0]);     // sra</span>
<span class="line">       4'b0100:  result = a ^ b;      // xor</span>
<span class="line">       4'b1000:  result = a << unsigned'(b[4:0]);      // sll</span>
<span class="line">       4'b1001:  result = unsigned'(a) < unsigned'(b);     // sltu</span>
<span class="line">       4'b1110:  result = b;           // lui</span>
<span class="line">       default:  result = 32'bx;</span>
<span class="line">     endcase</span>
<span class="line">   // overflow</span>
<span class="line">   assign overflow = ~(alucontrol[0] ^ a[31] ^ b[31]) & (a[31] ^ sum[31]) & isAddSub;</span>
<span class="line">   // negative</span>
<span class="line">   assign negative = result[31];</span>
<span class="line">   // Cout</span>
<span class="line">   assign carry = fullsum[32];</span>
<span class="line">   // zero</span>
<span class="line">   assign zero = (result == 32'b0);</span>
<span class="line"></span>
<span class="line">endmodule // alu</span></code></pre>

        </div>

        <a href="https://github.com/Frosty-Animal/Computer-Architecture" target="_blank" class="github-button-orange">
          <i class="fab fa-github"></i>
          View Full Code Base on GitHub
        </a>
      </div>
      </section>

      <h3>Lessons Learned</h3>
      <p>
        This project provided invaluable hands-on experience with electronics integration, precision assembly,
        and system optimization. The iterative process of building, testing, and refining taught important
        engineering principles that have been applicable to subsequent projects. The combination of mechanical,
        electrical, and software challenges made this an excellent introduction to systems engineering.
      </p>
    </div>
  </div>
</div>

<footer>
  <p>&copy; <script>document.write(new Date().getFullYear())</script> Isaiah Hajabolhassan. All Rights Reserved.</p>
  <a href="https://github.com/Frosty-Animal" target="_blank">
    <i class="fab fa-github"></i> GitHub
  </a>
  <a href="https://www.linkedin.com/in/isaiah-h/" target="_blank">
    <i class="fab fa-linkedin"></i> LinkedIn
  </a>
  <a href="mailto:Isaiahmh28@gmail.com">
    <i class="fas fa-envelope"></i> Email
  </a>
</footer>

<script>
  // Slideshow functionality
  let slideIndex = 1;
  showSlides(slideIndex);

  function plusSlides(n) {
    showSlides(slideIndex += n);
  }

  function currentSlide(n) {
    showSlides(slideIndex = n);
  }

  function showSlides(n) {
    const slides = document.querySelectorAll(".slide");
    const dots = document.querySelectorAll(".dot");

    if (n > slides.length) slideIndex = 1;
    if (n < 1) slideIndex = slides.length;

    slides.forEach(slide => (slide.style.display = "none"));
    dots.forEach(dot => dot.classList.remove("active-dot"));

    slides[slideIndex - 1].style.display = "block";
    dots[slideIndex - 1].classList.add("active-dot");
  }

  // Collapsible sections functionality
  function toggleSection(sectionId) {
    const content = document.getElementById(sectionId);
    const header = content.previousElementSibling;

    // Close all other sections
    document.querySelectorAll('.section-content').forEach(section => {
      if (section.id !== sectionId) {
        section.classList.remove('active');
        section.previousElementSibling.classList.remove('active');
      }
    });

    // Toggle current section
    content.classList.toggle('active');
    header.classList.toggle('active');
  }

  // Auto-open the overview section on page load
  document.addEventListener('DOMContentLoaded', function() {
    toggleSection('overview');
  });
</script>

</body>
</html>